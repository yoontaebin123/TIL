## **메모리 관리 전략**
프로세스는 간단하게 PCB가 실행되며, OS가 실행한 프로그램의 코드를 읽어들여 이 코드를 프로세스에 할당된 메모리의 Code Segment에 저장을 한다.   
그렇게 되면서 전역 변수 및 Static 변수들은 Data Segment에 할당되며, Heap과 Stack은 초기 메모리주소만 초기화가 된다.   
마지막으로 PCB에는 여러 정보가 기록되면 ReadyQueue에 등록이 되고, 스케줄러에 따라서 CPU에 할당받기를 기다린다.

즉, 이를 정리해보면 ``보조 기억장치(하드 디스크) -> 주 기억장치(메모리) -> CPU`` 크게 이와같은 순서로 등록이 된다.

더 자세히 들어가보면 Register -> Cache -> Memory -> Disk 의 계층이 있지만, 우선 위에 큰 순서로 보자면 프로세스가 CPU에 할당되기 전에는 "메모리"에서 Ready Queue 에서 대기를 하게된다.

자, 프로세스가 CPU에 할당되기 전 메모리에 잔류하고 있다는 사실을 알게 되었고, 과정에서 주 기억장치(메모리)를 꼭 거친다는것을 알게 되었다. 중간 다리 역할을 하며, 터미널같은 존재인 메모리를 잘 관리하지 못하면 한정된 자원을 비효율적으로 사용해 성능이 저하될 수 있다.

위와같은 이유로 메모리 관리가 필요하게 되었으며 이런 메모리 관리를 위한 전략으로 ``Swapping, Fragmentation, Paging, Segmentation`` 까지 총 4개가 존재한다.

### **Swapping**
Swap은 맞바꾼다 라는 의미를 가진다.

표준 Swapping 방식으로는 Round-Robin과 같은 스케줄링 알고리즘이 사용되며, CPU할당이 끝난 프로세스는 보조 기억장치로 보내고 다른 프로세스의 메모리를 불러들인다.

보조 기억장치에 있던 것을 다시 로딩시켜야 하므로 시간이 길게 걸리지만, 한정된 메모리에 더 많은 프로세스를 실행할 수 있다는 장점이 존재한다.

#### **VVM(Virtual Memory Management)**
메인 메모리가 8GB이지만, 10GB의 프로그램을 돌릴 수 있게 해주는 방법이다.
이게 가능한 이유는 위 예시에서는 부족한 2GB는 보조 기억장치(하드디스크)에 저장하고 있다가 필요하면 부분적으로 Swap해주는 방식을 사용하기 때문에 가능하다.

#### **Swapping과 VVM은 같은가?**
이 두개의 개념은 다르다고 볼 수 있다.

Swapping은 프로세스 단위로 Swap-out Swap-in을 하지만,   
VVM은 프로세스의 일부를 Swap-out Swap-in을 한다.

### **Fragment(단편화)**
메모리의 공간이 비효율적으로 사용되어 저장 공간이 낭비되는 현상을 이야기 한다.
이러한 단편화로 생기는 현상은 아래와 같으며, 이러한 단편화는 프로세스를 기준으로 내부 단편화와 외부 단편화로 나뉜다.
+ 총 메모리 공간은 충분하지만 실제 사용이 불가능하다.
+ 실제 사용 가능한 메모리 공간이 줄어들어 시스템 성능 저하를 일으킬 수 있다.
    + 사용할 수 있는 공간을 찾는 과정이 필요함
    + 페이지를 너무 자주 교체함
    + Swapping

#### **내부 단편화(Internal Fragment)**
할당한 영역 중 사용되지 않은 공간으로 인해 공간이 낭비되는것을 의미한다.   
즉, 프로세스에게 1GB의 메모리를 할당해 주었지만 실제로 프로세스가 사용하는 메모리는 120MB이다.

이는 페이징 기법에서 나타나는 문제점 중 하나인데, 한 페이지를 너무 크게 할 경우에 생기는 문제이다.

#### **외부 단편화(External Fragment)**
메모리의 여유 공간 즉, 메모리 안의 프로세스간의 간격이 띄엄띄엄 존재해서 실제로 사용할 수 없는 경우를 의미한다.   
4GB의 메모리에 1GB의 공간이 남아서 100MB인 프로세스가 메모리에 올라가려고 하는데, 무슨 메모리의 간격이 90MB라서 올라가지 못했다. 90MB가 여럿이 모여 1GB로 표시되긴 하겠지만 실제로는 메모리를 모두 사용하고있는 셈이다.

이는 Segmentaion 에서 나타나는 문제점 중 하나이며, 동적 메모리 할당 해제를 자주하면 나타난다.

### **Paging**
"하나의 프로세스에는 연속적인 메모리 공간이 할당되어야 한다" 라는 제약이 있다.   
하지만, Paging이라는 메모리 관리 기법에서는 이러한 제약을 없애버렸다.

외부 단편화 문제를 해결하기 위해서 나온 개념인데, 이는 크게 물리 메모리와 논리 메모리로 분리가 된다.

물리 메모리는 Frame이라는 고정 크기로 분리되어있고, 논리 메모리는 프로세스가 점유하는 메모리로, 페이지라는 고정된 크기의 블록으로 분리 된다. 이는 페이지 교체 알고리즘으로 교체가 된다.

> 외부 단편화의 문제점은 각 메모리 사이에 간격이 애매하기 때문에 일어났다고 한다. 그럼 메모리의 공간이 4000MB이면 100MB씩 쪼갠다고 가정을 해보자.
>
> 이제 프로세스가 메모리에 등록이 된다면, 이 전에 해당 프로세스에서 사용할 수 있는 메모리의 적정량을 정해준다. 이를 논리 메모리라고 하며 Page 라고도 한다. 220MB의 공간만을 사용한다 하면 100MB블록을 3개를 만들어주어 메모리에 적재를 해주며 페이지에는 각 블록들의 메모리 주소 값을 저장해둔다. 여기서 100MB 블록들을 물리 메모리라고 하며 Frame이라고도 한다.

위 예시를 보았을 때 뭔가 이상한점을 느낄 수 있을것이다.   
100/100/100 으로 나누었을 때 한군데에 80이 남는다.   
이게 바로 Paging의 문제점인 내부단편화의 발생이다.

### **Segmentaion**
페이징에서처럼 메모리를 같은 크기로 나누는것이 아닌 서로 다른 크기의 논리적 단위인 Segment로 분할을 한다.

페이징에서는 메모리 위에 올라간 Frame들은 논리적으로 독립된 내용들이 구분되지 못한다. 쉽게 예시를 들면 120MB인 함수가 100/20 이렇게 나뉜다는것이다. 이들을 동작하기 위해서는 Frame들이 Page를 기반으로 동작이 되어야 한다라는 문제점이 있었는데, 이를 해결하기위해 나온 방법이 Segmentation이다.

Segmentation은 위에 말한 문제점을 해결했다싶이 논리적으로 독린된 의미의 Segment 단위로 동작하는 메모리 관리 기법이다. 여기서도 프로세스에 할당된 메모리가 분리가 된다. 이 분리된 세그먼트가 디스크립터 테이블에 저장이 되는데, 이는 운영체제가 관리하는 Segment 저장 영역이다.

우리가 여태 공부를 하면서 프로세스는 Code, Data, Stack등으로 나뉘어져있다고 했는데 이렇게 나뉘어지는게 Segmentation 기법이 들어갔기 때문에 나뉘어지는 것이다.

> 220MB의 공간을 할당받는 프로세스는 함수는 50/50/120 크기이다. 이 크기별로 Paging 기법과 동일하게 프로세스를 나누어 메모리에 배치를 한다.

하지만, 가변적인 크기라는 단점이 있어 여러번의 Swapping이 일어나게 되면 외부 단편화의 문제가 생기게된다.

### **Paging vs Segmentation**
> 이 둘은 각자의 장/단점이 존재하며 Memory Fragment를 해결하기 위해서 나타난 메모리 관리 기법이다.   
각 기법의 특징은 아래와 같으며, OS에서는 해당 기법들의 장점들만을 채택하여 Segmentation을 Paging해준다고 한다.

#### **Fragment**
+ Paging - 내부 단편화 발생
+ Segment - 외부 단편화 발생

#### **Size**
+ Paging - 고정적인 크기
+ Segment - 가변적인 크기
